Q1:3 type of price return:Classical Brownian Motion;Arithmetic Return System; Geometric Brownian Motion
A1:
import numpy as np
import matplotlib.pyplot as plt

# Set parameters
np.random.seed(42)
initial_price = 100  # Initial price at time t-1
sigma_squared = 0.01  # Variance of returns
num_simulations = 10000  # Number of simulations

# Simulate returns: N(0, σ^2)
returns = np.random.normal(0, np.sqrt(sigma_squared), num_simulations)

# Calculate prices for each model
price_brownian = initial_price + returns  # Classical Brownian Motion
price_arithmetic = initial_price * (1 + returns)  # Arithmetic Return System
price_logarithmic = initial_price * np.exp(returns)  # Log Return (Geometric Brownian Motion)


# Print the calculated expected values and standard deviations
print("Classical Brownian Motion:")
print(f"Expected Value (Mean): {mean_brownian:.4f}, Standard Deviation: {std_brownian:.4f}")
print("Calculation Details: Expected value ≈ initial_price + mean(return)")

print("\nArithmetic Return System:")
print(f"Expected Value (Mean): {mean_arithmetic:.4f}, Standard Deviation: {std_arithmetic:.4f}")
print("Calculation Details: Expected value ≈ initial_price * (1 + mean(return))")

print("\nLog Return or Geometric Brownian Motion:")
print(f"Expected Value (Mean): {mean_logarithmic:.4f}, Standard Deviation: {std_logarithmic:.4f}")
print("Calculation Details: Expected value ≈ initial_price * exp(mean(return))")

# Visualize distributions
plt.figure(figsize=(10, 6))
plt.hist(price_brownian, bins=50, alpha=0.5, label='Classical Brownian Motion')
plt.hist(price_arithmetic, bins=50, alpha=0.5, label='Arithmetic Return System')
plt.hist(price_logarithmic, bins=50, alpha=0.5, label='Log Return (Geometric Brownian Motion)')
plt.title('Price Distributions for Different Models')
plt.xlabel('Price at time t')
plt.ylabel('Frequency')
plt.legend()
plt.show()






Q2: 5 methods to calculate VaR
A2:
import pandas as pd
import numpy as np
from scipy.stats import norm, t
import statsmodels.api as sm
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

# Define a function to calculate returns using different methods
def calculate_returns(prices, method='arithmetic'):
    if method == 'arithmetic':
        returns = prices.pct_change().dropna()
    elif method == 'logarithmic':
        returns = np.log(prices / prices.shift(1)).dropna()
    else:
        raise ValueError("Invalid method. Choose 'arithmetic' or 'logarithmic'.")
    return returns

# Load DailyPrices.csv data
daily_prices = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/DailyPrices.csv', parse_dates=['Date'], index_col='Date')

# Calculate arithmetic returns for all stocks
arithmetic_returns = calculate_returns(daily_prices, method='arithmetic')

# Calculate arithmetic returns for META and adjust to remove the mean
meta_returns = arithmetic_returns['META']
meta_returns_adjusted = meta_returns - meta_returns.mean()

# Define a function to calculate VaR using different methods
def calculate_var(returns, method='normal', alpha=0.05, lambda_value=0.94):
    if method == 'normal':
        # Calculate VaR using Normal distribution
        mean = returns.mean()
        std = returns.std()
        VaR = -norm.ppf(alpha) * std

    elif method == 'ewma':
        # Calculate VaR using Exponentially Weighted Moving Average (EWMA)
        ewma_std = returns.ewm(span=(2 / (1 - lambda_value) - 1)).std().iloc[-1]
        VaR = -norm.ppf(alpha) * ewma_std

    elif method == 't-distribution':
        # Calculate VaR using MLE fitted T-distribution
        params = t.fit(returns)  # Fit T-distribution
        df, loc, scale = params
        VaR = -t.ppf(alpha, df, loc, scale)

    elif method == 'ar1':
        # Calculate VaR using AR(1) model
        model = ARIMA(returns, order=(1, 0, 0))
        model_fit = model.fit()
        predicted_std = np.sqrt(model_fit.params['sigma2'])
        VaR = -norm.ppf(alpha) * predicted_std

    elif method == 'historical':
        # Calculate VaR using Historical Simulation
        sorted_returns = np.sort(returns)
        VaR = -sorted_returns[int(alpha * len(sorted_returns))]

    else:
        raise ValueError("Invalid method. Choose 'normal', 'ewma', 't-distribution', 'ar1', or 'historical'.")
    
    return VaR

# Calculate VaR using different methods
VaR_normal = calculate_var(meta_returns_adjusted, method='normal')
VaR_ewma = calculate_var(meta_returns_adjusted, method='ewma')
VaR_t_dist = calculate_var(meta_returns_adjusted, method='t-distribution')
VaR_ar1 = calculate_var(meta_returns_adjusted, method='ar1')
VaR_historical = calculate_var(meta_returns_adjusted, method='historical')

# Compare the results of the five methods and print
print("\nComparison of VaR Values for META Stock Using Different Methods:")
print(f"VaR using Normal Distribution: {VaR_normal:.4f}")
print(f"VaR using EWMA (λ = 0.94): {VaR_ewma:.4f}")
print(f"VaR using MLE Fitted T Distribution: {VaR_t_dist:.4f}")
print(f"VaR using AR(1) Model: {VaR_ar1:.4f}")
print(f"VaR using Historical Simulation: {VaR_historical:.4f}")

# Visualize the VaR values comparison using a bar chart
methods = ['Normal', 'EWMA', 'T-Distribution', 'AR(1)', 'Historical']
VaR_values = [VaR_normal, VaR_ewma, VaR_t_dist, VaR_ar1, VaR_historical]

plt.figure(figsize=(10, 6))
plt.bar(methods, VaR_values, color='skyblue')
plt.title('VaR Comparison Using Different Methods for META Stock')
plt.xlabel('VaR Calculation Method')
plt.ylabel('VaR Value')
plt.show()







Q3:
A3:

