Q1:3 type of price return:Classical Brownian Motion;Arithmetic Return System; Geometric Brownian Motion
A1:
import numpy as np
import matplotlib.pyplot as plt

# Set parameters
np.random.seed(42)
initial_price = 100  # Initial price at time t-1
sigma_squared = 0.01  # Variance of returns
num_simulations = 10000  # Number of simulations

# Simulate returns: N(0, σ^2)
returns = np.random.normal(0, np.sqrt(sigma_squared), num_simulations)

# Calculate prices for each model
price_brownian = initial_price + returns  # Classical Brownian Motion
price_arithmetic = initial_price * (1 + returns)  # Arithmetic Return System
price_logarithmic = initial_price * np.exp(returns)  # Log Return (Geometric Brownian Motion)


# Print the calculated expected values and standard deviations
print("Classical Brownian Motion:")
print(f"Expected Value (Mean): {mean_brownian:.4f}, Standard Deviation: {std_brownian:.4f}")
print("Calculation Details: Expected value ≈ initial_price + mean(return)")

print("\nArithmetic Return System:")
print(f"Expected Value (Mean): {mean_arithmetic:.4f}, Standard Deviation: {std_arithmetic:.4f}")
print("Calculation Details: Expected value ≈ initial_price * (1 + mean(return))")

print("\nLog Return or Geometric Brownian Motion:")
print(f"Expected Value (Mean): {mean_logarithmic:.4f}, Standard Deviation: {std_logarithmic:.4f}")
print("Calculation Details: Expected value ≈ initial_price * exp(mean(return))")

# Visualize distributions
plt.figure(figsize=(10, 6))
plt.hist(price_brownian, bins=50, alpha=0.5, label='Classical Brownian Motion')
plt.hist(price_arithmetic, bins=50, alpha=0.5, label='Arithmetic Return System')
plt.hist(price_logarithmic, bins=50, alpha=0.5, label='Log Return (Geometric Brownian Motion)')
plt.title('Price Distributions for Different Models')
plt.xlabel('Price at time t')
plt.ylabel('Frequency')
plt.legend()
plt.show()






Q2:
A2:

