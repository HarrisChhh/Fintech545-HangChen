# Problem 1

import numpy as np
from scipy.stats import norm
import math
from datetime import datetime

# Parameters
S = 151.03       # Current stock price
K = 165          # Strike price
current_date = datetime(2022, 3, 13)
expiration_date = datetime(2022, 4, 15)
T = (expiration_date - current_date).days / 365  # Time to expiration (in years)
r = 0.0425       # Risk-free rate
sigma = 0.2      # Assumed volatility (20%)
q = 0.0053       # Continuously compounded dividend yield
steps = 100      # Steps in the binomial tree
dividend_dates = [29 / 365]  # Dividend payment date (relative to expiration date)
dividend_amounts = [0.88]    # Dividend amount
h = 1e-4         # Small increment for finite difference method

# Black-Scholes-Merton formula to calculate European option price
def black_scholes_price(S, K, T, r, sigma, option_type="call", q=0):
    d1 = (math.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * math.sqrt(T))
    d2 = d1 - sigma * math.sqrt(T)
    if option_type == "call":
        price = S * math.exp(-q * T) * norm.cdf(d1) - K * math.exp(-r * T) * norm.cdf(d2)
    elif option_type == "put":
        price = K * math.exp(-r * T) * norm.cdf(-d2) - S * math.exp(-q * T) * norm.cdf(-d1)
    return price

# Calculate Greeks
def calculate_greeks(S, K, T, r, sigma, option_type="call", q=0):
    d1 = (math.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * math.sqrt(T))
    d2 = d1 - sigma * math.sqrt(T)
    delta = norm.cdf(d1) if option_type == "call" else -norm.cdf(-d1)
    gamma = norm.pdf(d1) / (S * sigma * math.sqrt(T))
    vega = S * math.exp(-q * T) * norm.pdf(d1) * math.sqrt(T)
    theta = (-S * norm.pdf(d1) * sigma / (2 * math.sqrt(T)) - r * K * math.exp(-r * T) * norm.cdf(d2)) if option_type == "call" else (-S * norm.pdf(d1) * sigma / (2 * math.sqrt(T)) + r * K * math.exp(-r * T) * norm.cdf(-d2))
    rho = K * T * math.exp(-r * T) * norm.cdf(d2) if option_type == "call" else -K * T * math.exp(-r * T) * norm.cdf(-d2)
    return {"delta": delta, "gamma": gamma, "vega": vega, "theta": theta, "rho": rho}

# Calculate Greeks using the finite difference method
def finite_difference_greeks(S, K, T, r, sigma, option_type="call", q=0, h=1e-4):
    delta = (black_scholes_price(S + h, K, T, r, sigma, option_type, q) - black_scholes_price(S - h, K, T, r, sigma, option_type, q)) / (2 * h)
    gamma = (black_scholes_price(S + h, K, T, r, sigma, option_type, q) - 2 * black_scholes_price(S, K, T, r, sigma, option_type, q) + black_scholes_price(S - h, K, T, r, sigma, option_type, q)) / (h ** 2)
    vega = (black_scholes_price(S, K, T, r, sigma + h, option_type, q) - black_scholes_price(S, K, T, r, sigma - h, option_type, q)) / (2 * h)
    theta = (black_scholes_price(S, K, T - h, r, sigma, option_type, q) - black_scholes_price(S, K, T + h, r, sigma, option_type, q)) / (2 * h)
    rho = (black_scholes_price(S, K, T, r + h, sigma, option_type, q) - black_scholes_price(S, K, T, r - h, sigma, option_type, q)) / (2 * h)
    return {"delta": delta, "gamma": gamma, "vega": vega, "theta": theta, "rho": rho}

# Binomial tree model implementation
def binomial_tree_american_option(S, K, T, r, sigma, steps, option_type="call", dividend_dates=None, dividend_amounts=None):
    dt = T / steps
    u = math.exp(sigma * math.sqrt(dt))
    d = 1 / u
    p = (math.exp(r * dt) - d) / (u - d)
    prices = np.zeros((steps + 1, steps + 1))
    values = np.zeros((steps + 1, steps + 1))
    for i in range(steps + 1):
        prices[steps, i] = S * (u ** i) * (d ** (steps - i))
    for i in range(steps + 1):
        values[steps, i] = max(0, prices[steps, i] - K) if option_type == "call" else max(0, K - prices[steps, i])
    for j in range(steps - 1, -1, -1):
        for i in range(j + 1):
            stock_price = prices[j, i]
            if dividend_dates and dividend_amounts:
                for date, amount in zip(dividend_dates, dividend_amounts):
                    if j * dt >= date:
                        stock_price -= amount
            values[j, i] = max(stock_price - K if option_type == "call" else K - stock_price, math.exp(-r * dt) * (p * values[j + 1, i + 1] + (1 - p) * values[j + 1, i]))
    return values[0, 0]

# Compare Greek letters for call and put options (BSM vs Finite Difference)
call_greeks_bsm = calculate_greeks(S, K, T, r, sigma, "call", q)
put_greeks_bsm = calculate_greeks(S, K, T, r, sigma, "put", q)
call_greeks_fd = finite_difference_greeks(S, K, T, r, sigma, "call", q, h)
put_greeks_fd = finite_difference_greeks(S, K, T, r, sigma, "put", q, h)

# Option prices comparison between BSM and binomial tree
call_price_bsm = black_scholes_price(S, K, T, r, sigma, "call", q)
put_price_bsm = black_scholes_price(S, K, T, r, sigma, "put", q)
call_price_binomial_dividend = binomial_tree_american_option(S, K, T, r, sigma, steps, "call", dividend_dates, dividend_amounts)
put_price_binomial_dividend = binomial_tree_american_option(S, K, T, r, sigma, steps, "put", dividend_dates, dividend_amounts)
call_price_binomial = binomial_tree_american_option(S, K, T, r, sigma, steps, "call", dividend_dates = 0, dividend_amounts = 0)
put_price_binomial = binomial_tree_american_option(S, K, T, r, sigma, steps, "put", dividend_dates = 0, dividend_amounts = 0)

def binomial_tree_greeks(S, K, T, r, sigma, steps, option_type="call", dividend_dates=None, dividend_amounts=None, h=1e-4):
    # Delta: Sensitivity to price change
    delta = (binomial_tree_american_option(S + h, K, T, r, sigma, steps, option_type, dividend_dates, dividend_amounts) - 
             binomial_tree_american_option(S - h, K, T, r, sigma, steps, option_type, dividend_dates, dividend_amounts)) / (2 * h)
    
    # Gamma: Sensitivity to the rate of change of the stock price
    gamma = (binomial_tree_american_option(S + h, K, T, r, sigma, steps, option_type, dividend_dates, dividend_amounts) - 
             2 * binomial_tree_american_option(S, K, T, r, sigma, steps, option_type, dividend_dates, dividend_amounts) + 
             binomial_tree_american_option(S - h, K, T, r, sigma, steps, option_type, dividend_dates, dividend_amounts)) / (h ** 2)
    
    # Vega: Sensitivity to volatility change
    vega = (binomial_tree_american_option(S, K, T, r, sigma + h, steps, option_type, dividend_dates, dividend_amounts) - 
            binomial_tree_american_option(S, K, T, r, sigma - h, steps, option_type, dividend_dates, dividend_amounts)) / (2 * h)
    
    # Theta: Sensitivity to time decay
    theta = (binomial_tree_american_option(S, K, T - h, r, sigma, steps, option_type, dividend_dates, dividend_amounts) - 
             binomial_tree_american_option(S, K, T + h, r, sigma, steps, option_type, dividend_dates, dividend_amounts)) / (2 * h)
    
    # Rho: Sensitivity to interest rate change
    rho = (binomial_tree_american_option(S, K, T, r + h, sigma, steps, option_type, dividend_dates, dividend_amounts) - 
           binomial_tree_american_option(S, K, T, r - h, sigma, steps, option_type, dividend_dates, dividend_amounts)) / (2 * h)
    
    return {
        "delta": delta,
        "gamma": gamma,
        "vega": vega,
        "theta": theta,
        "rho": rho
    }
call_greeks_bt = binomial_tree_greeks(S, K, T, r, sigma, int(steps), "call", q)
put_greeks_bt = binomial_tree_greeks(S, K, T, r, sigma, int(steps), "put", q)

# result
print("BSM vs Finite Difference Greeks Comparison:")
print("Call Option Greeks (BSM):", call_greeks_bsm)
print("Call Option Greeks (Finite Difference):", call_greeks_fd)
print("Put Option Greeks (BSM):", put_greeks_bsm)
print("Put Option Greeks (Finite Difference):", put_greeks_fd)
print("\nOption Prices Comparison (BSM vs Binomial):")
print(f"Call Price (BSM): {call_price_bsm:.4f}")
print(f"Put Price (BSM): {put_price_bsm:.4f}")
print(f"Call Price (Binomial, without dividend): {call_price_binomial:.4f}")
print(f"Put Price (Binomial, without dividend): {put_price_binomial:.4f}")
print(f"Call Price (Binomial, with dividend): {call_price_binomial_dividend:.4f}")
print(f"Put Price (Binomial, with dividend): {put_price_binomial_dividend:.4f}")
print("Call Option Greeks (Binomial Tree):", call_greeks_bt)
print("Put Option Greeks (Binomial Tree):", put_greeks_bt)


# Problem 2
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt
from scipy.optimize import brentq
from scipy.stats import norm
from datetime import datetime
from google.colab import drive

#  load problem2.csv
drive.mount('/content/drive')
portfolio_path = '/content/drive/MyDrive/Colab Notebooks/problem2.csv'
portfolio_df = pd.read_csv(portfolio_path)

daily_prices_path = '/content/drive/MyDrive/Colab Notebooks/DailyPrices.csv'
daily_prices_df = pd.read_csv(daily_prices_path)

daily_prices_df['Date'] = pd.to_datetime(daily_prices_df['Date'])
daily_prices_df.set_index('Date', inplace=True)


# Black-Scholes formula with discrete dividend adjustment
def black_scholes_discrete_dividend(S, K, T, r, dividend, t_div, sigma, option_type="call"):
    # Calculate the present value of the dividend
    PV_dividend = dividend * np.exp(-r * t_div)
    # Adjusted stock price
    S_adj = S - PV_dividend

    # Calculate d1 and d2 using the adjusted stock price
    d1 = (np.log(S_adj / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    # Compute the price for a call or put option
    if option_type == "call":
        price = S_adj * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    elif option_type == "put":
        price = K * np.exp(-r * T) * norm.cdf(-d2) - S_adj * norm.cdf(-d1)
    return price

# Implied volatility calculation
def implied_volatility_discrete_dividend(S, K, T, r, dividend, t_div, market_price, option_type="call", tol=1e-5, max_iter=100):
    sigma = 0.2  # Initial guess for implied volatility
    for i in range(max_iter):
        price = black_scholes_discrete_dividend(S, K, T, r, dividend, t_div, sigma, option_type)
        # Calculate d1 for vega calculation
        PV_dividend = dividend * np.exp(-r * t_div)
        S_adj = S - PV_dividend
        d1 = (np.log(S_adj / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
        vega = S_adj * norm.pdf(d1) * np.sqrt(T)
        
        # Newton-Raphson update for implied volatility
        price_diff = price - market_price
        if abs(price_diff) < tol:
            return sigma
        
        sigma -= price_diff / vega  # Update implied volatility

# straddle call
S = 165  
K = 150  
current_date = datetime(2023, 3, 3)
div_date = datetime(2023, 3, 15)
expiration_date = datetime(2023, 4, 21)
T = (expiration_date - current_date).days / 365
r = 0.0425 
dividend = 1
t_div = (div_date - current_date).days / 365
market_price_call = 6.8  
market_price_put = 4.85

iv_call = 0 #implied_volatility_discrete_dividend(S, K, T, r, dividend, t_div, market_price_call, option_type="call")
iv_put = implied_volatility_discrete_dividend(S, K, T, r, dividend, t_div, market_price_put, option_type="put")

print(f"：{iv_call}")
print(f"：{iv_put}")

def calculate_option_delta(S, K, T, r, sigma, option_type="call"):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    if option_type == "call":
        return norm.cdf(d1)
    elif option_type == "put":
        return -norm.cdf(-d1)

calculate_option_delta(S, K, T, r, iv_call, option_type="call")
calculate_option_delta(S, K, T, r, iv_put, option_type="put")

np.random.seed(0)
simulated_returns = np.random.normal(0, iv_call / np.sqrt(252), int(T * 252))  # Example using iv_call
simulated_prices = S * np.exp(np.cumsum(simulated_returns))

call_payoffs = np.maximum(simulated_prices - K, 0)
put_payoffs = np.maximum(K - simulated_prices, 0)
straddle_payoffs = call_payoffs + put_payoffs
straddle_losses = straddle_payoffs - (call_payoffs[0] + put_payoffs[0])


results = []

for idx, row in portfolio_df.iterrows():
    portfolio_name = row['Portfolio']
    holding = row['Holding']
    option_price = row['CurrentPrice']
    
    portfolio_value = option_price * holding
    delta = row.get('Delta', 1)  
    

    var, es = calculate_var_es(portfolio_value, delta, std_dev, risk_free_rate, dividend_payment)

    results.append({
        'Portfolio': portfolio_name,
        'Value': portfolio_value,
        'VaR': var,
        'ES': es
    })

results_df = pd.DataFrame(results)
print(results_df)




# Problem 3
import pandas as pd
import numpy as np
from scipy.optimize import minimize

# 1. load data
fama_french_data = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/F-F_Research_Data_Factors_daily.CSV')
momentum_data = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/F-F_Momentum_Factor_daily.CSV')
daily_prices = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/DailyPrices.csv')

#  2. Data Preprocessing
# Convert factor values from percentages to decimals
fama_french_data[['Mkt-RF', 'SMB', 'HML', 'RF']] /= 100
momentum_data.columns = momentum_data.columns.str.strip()  # Remove extra spaces from column names
momentum_data['Mom'] /= 100

# Convert date columns to a consistent format to merge the data
fama_french_data['Date'] = fama_french_data['Date'].astype(str)
momentum_data['Date'] = momentum_data['Date'].astype(str)
merged_factors = pd.merge(fama_french_data, momentum_data, on='Date')

# Extract selected stocks' daily prices and calculate daily returns
selected_stocks = ["AAPL", "META", "UNH", "MA", "MSFT", "NVDA", "HD", "PFE", "AMZN", 
                   "BRK-B", "PG", "XOM", "TSLA", "JPM", "V", "DIS", "GOOGL", "JNJ", 
                   "BAC", "CSCO"]
selected_data = daily_prices[["Date"] + selected_stocks].copy()
selected_data["Date"] = pd.to_datetime(selected_data["Date"])
selected_data = selected_data.sort_values(by="Date")
returns_data = selected_data[selected_stocks].pct_change().dropna()

# 3. Calculate Expected Annual Returns and Covariance Matrix
# Expected annual returns
expected_annual_return = returns_data.mean() * 252
# Annualized covariance matrix
annual_covariance_matrix = returns_data.cov() * 252

# Display the annual covariance matrix for the 20 stocks
print("Annual Covariance Matrix for the 20 stocks:")
print(annual_covariance_matrix)

# 4. Portfolio Optimization
# Risk-free rate
risk_free_rate = 0.05

# Convert to numpy arrays for optimization
expected_returns = expected_annual_return.values
cov_matrix = annual_covariance_matrix.values
num_assets = len(selected_stocks)

# Define the objective function (negative Sharpe Ratio)
def neg_sharpe_ratio(weights):
    portfolio_return = np.dot(weights, expected_returns)
    portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_volatility
    return -sharpe_ratio

# Constraints: weights sum to 1
constraints = ({'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1})
# Bounds: weights between 0 and 1
bounds = tuple((0, 1) for _ in range(num_assets))
# Initial guess for weights (equal distribution)
initial_guess = num_assets * [1. / num_assets,]

# Optimization to find weights that maximize the Sharpe Ratio
result = minimize(neg_sharpe_ratio, initial_guess, method='SLSQP', bounds=bounds, constraints=constraints)

# Extract optimized portfolio weights, expected return, volatility, and Sharpe ratio
optimal_weights = result.x
optimal_return = np.dot(optimal_weights, expected_returns)
optimal_volatility = np.sqrt(np.dot(optimal_weights.T, np.dot(cov_matrix, optimal_weights)))
optimal_sharpe_ratio = (optimal_return - risk_free_rate) / optimal_volatility

# Print the results
print("Optimal Weight Allocation:", optimal_weights)
print("Expected Annual Return:", optimal_return)
print("Annual Volatility:", optimal_volatility)
print("Sharpe Ratio:", optimal_sharpe_ratio)
